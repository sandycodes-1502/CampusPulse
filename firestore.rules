/**
 * Core Philosophy: This ruleset enforces a strict Role-Based Access Control (RBAC) model combined with user ownership.
 * There are three primary roles: 'admin', 'security', and 'student'. An authenticated user's role is determined
 * by the existence of a corresponding document in the `/roles_admin` or `/roles_security` collections. The 'student'
 * role is implicitly tied to data ownership within the `/users/{userId}` data tree. Admins have broad read access
 * for oversight and specific write permissions, while security personnel have specific operational privileges (e.g.,
 * managing outpasses and logs). Students are restricted to managing their own personal data.
 *
 * Data Structure:
 * - User-specific data (profiles, outpasses, complaints, etc.) is nested under `/users/{userId}` to leverage
 *   Firestore's path-based security for ownership.
 * - Role assignments are stored in top-level collections (`/roles_admin/{userId}`, `/roles_security/{userId}`) for
 *   efficient, database-wide role checks using `exists()`.
 * - Global or system-wide data (e.g., announcements, hostel rooms) are stored in top-level collections.
 *
 * Key Security Decisions:
 * - Default Deny: All paths are closed by default. Access is granted explicitly.
 * - Role Checks via Document Existence: A user is considered an 'admin' or 'security' if a document with their UID
 *   exists in the corresponding role collection. This is a highly performant and secure pattern.
 * - Strict Ownership: Students can only access data within their own `/users/{userId}` path. Listing documents in
 *   other users' subcollections is strictly forbidden.
 * - No User Enumeration: Listing the top-level `/users` collection is disallowed to protect user privacy.
 * - Admin and Security Access: Admins and Security can read specific user-nested data (like outpasses or complaints)
 *   using direct `get` requests for moderation, but they cannot `list` entire user subcollections to prevent data scraping.
 *
 * Denormalization for Authorization: To ensure fast and simple rules, relational data required for authorization is
 * denormalized. For instance, an `outpass` document under `/users/{userId}/outpasses/{outpassId}` contains a `studentId`
 * field that must match the `{userId}` in the path. This avoids costly `get()` calls and makes ownership checks self-contained.
 *
 * Structural Segregation: Data with different security needs are stored in separate collections. For example, private
 * user data is segregated under `/users/{userId}`, while public-read data like `/announcements` is a top-level collection.
 * This makes list operations safer and rules easier to reason about.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    //=========================================================================
    // Helper Functions
    //=========================================================================

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requesting user's UID matches the provided userId,
     * verifying ownership of a document or data path.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the user is an owner and the document already exists.
     * Crucial for safe update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Checks if the user has an 'admin' role by checking for their UID
     * in the /roles_admin collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Checks if the user has a 'security' role by checking for their UID
     * in the /roles_security collection.
     */
    function isSecurity() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_security/$(request.auth.uid));
    }

    /**
     * On create, validates that a document's internal `userId` field
     * matches the `userId` from the path parameter.
     */
    function isCorrectUserOnCreate(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * On create, validates that a document's internal `studentId` field
     * matches the `userId` from the path parameter.
     */
    function isCorrectStudentOnCreate(userId) {
      return request.resource.data.studentId == userId;
    }

    /**
     * On update, ensures the `userId` field cannot be changed, preserving
     * the ownership link.
     */
    function isUserLinkImmutable() {
      return request.resource.data.userId == resource.data.userId;
    }

    /**
     * On update, ensures the `studentId` field cannot be changed, preserving
     * the ownership link.
     */
    function isStudentLinkImmutable() {
      return request.resource.data.studentId == resource.data.studentId;
    }

    //=========================================================================
    // Collection Rules
    //=========================================================================

    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId) || (isAdmin() && resource != null);
      allow delete: if false;

      match /students/{studentId} {
        allow get: if isOwner(userId) || isAdmin();
        allow list: if isOwner(userId) || isAdmin();
        allow create: if isOwner(userId) && isCorrectUserOnCreate(userId);
        allow update: if (isExistingOwner(userId) || (isAdmin() && resource != null)) && isUserLinkImmutable();
        allow delete: if false;
      }
      
      match /outpasses/{outpassId} {
        allow create: if isOwner(userId) && isCorrectStudentOnCreate(userId);
        allow update: if isOwner(userId) && resource.data.status == 'pending' && isStudentLinkImmutable();
        allow read, delete: if isOwner(userId);
      }
      
      match /complaints/{complaintId} {
        allow create: if isOwner(userId) && isCorrectStudentOnCreate(userId);
        allow read, delete: if isOwner(userId);
        allow update: if false; // Only admins can update via collection group
      }

      match /feedback/{feedbackId} {
        allow create: if isOwner(userId) && isCorrectStudentOnCreate(userId);
        allow read: if isOwner(userId);
        allow update, delete: if false; // Immutable
      }
      
      match /hostel_fees/{hostelFeeId} {
        allow read: if isOwner(userId);
        allow create, update, delete: if false; // Only admins can write via collection group
      }
    }

    match /roles_admin/{userId} {
      allow get: if isSignedIn();
      allow list, create, update, delete: if false;
    }

    match /roles_security/{userId} {
      allow get: if isSignedIn();
      allow list, create, update, delete: if false;
    }

    match /hostel_rooms/{hostelRoomId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if isAdmin() && resource != null;
    }

    match /entry_exit_logs/{entryExitLogId} {
      allow get: if isAdmin() || isSecurity() || (isSignedIn() && request.auth.uid == resource.data.studentId);
      allow list: if isAdmin() || isSecurity();
      allow create: if isSecurity() && request.resource.data.recordedBySecurityId == request.auth.uid;
      allow update, delete: if false;
    }

    match /announcements/{announcementId} {
      allow get, list: if isSignedIn();
      allow create: if isAdmin() && request.resource.data.adminId == request.auth.uid;
      allow update: if (isAdmin() && resource != null) && resource.data.adminId == request.auth.uid;
      allow delete: if (isAdmin() && resource != null) && resource.data.adminId == request.auth.uid;
    }
    
    //=========================================================================
    // Collection Group Rules
    //=========================================================================
    
    match /{path=**}/students/{studentId} {
      allow get, list: if isAdmin();
    }
    
    match /{path=**}/outpasses/{outpassId} {
      allow get, list: if isAdmin() || isSecurity();
      allow update: if (isAdmin() || isSecurity()) && resource != null;
    }
    
    match /{path=**}/complaints/{complaintId} {
      allow get, list, update: if isAdmin();
    }
    
    match /{path=**}/hostel_fees/{hostelFeeId} {
      allow get, list, create, update, delete: if isAdmin();
    }
    
    match /{path=**}/feedback/{feedbackId} {
      allow get, list: if isAdmin();
    }
  }
}
    